<!DOCTYPE html>

<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

    <title>Intersection</title>
    <script src='/js/d3.v6.min.js'></script>
    <script src='/js/chroma.min.js'></script>
    <script src='/js/lodash.min.js'></script>

    <!--<link rel='stylesheet' href='/css/null.css' />-->

    <link rel='stylesheet' href='/css/bootstrap4-toggle.min.css' />

    <!-- Bootstrap CSS CDN -->
    <link rel="stylesheet" href="/css/bootstrap.min.css" crossorigin="anonymous">
    <!-- Our Custom CSS -->
    <link rel="stylesheet" href="style3.css">
    <!-- Scrollbar Custom CSS -->
    <link rel="stylesheet" href="/css/jquery.mCustomScrollbar.css">

    <script src='/js/f4afbaa213.js' crossorigin='anonymous'></script>

    <script src="/js/jquery.min.js" crossorigin="anonymous"></script>

    <script src="/js/popper.min.js" crossorigin="anonymous"></script>

    <script src="/js/bootstrap.min.js" crossorigin="anonymous"></script>

    <script src="/js/jquery.mCustomScrollbar.concat.min.js"></script>
    <script src='/js/bootstrap4-toggle.min.js'></script>
    <style>
        svg {
            outline: 1px solid gray;
            display: block;
            /*margin: 1em auto;*/
        }
        
        .drag {
            fill: rgba(100, 100, 100, 0.2);
            stroke: black;
            stroke-width: 1;
            cursor: pointer;
            z-index: -100;
        }
        
        .group {
            z-index: 100;
        }
        
        .dot {}
    </style>
</head>

<body>

    <svg id="tt"></svg>

    <script>
        let intersection = (_1st, _2nd) => {
            let x0 = _1st.x,
                y0 = _1st.y,
                r0 = _1st.r;
            let x1 = _2nd.x,
                y1 = _2nd.y,
                r1 = _2nd.r;
            let a, dx, dy, d, h, rx, ry;
            let x2, y2;

            /* dx and dy are the vertical and horizontal distances between
             * the circle centers.
             */
            dx = x1 - x0;
            dy = y1 - y0;

            /* Determine the straight-line distance between the centers. */
            d = Math.sqrt((dy * dy) + (dx * dx));

            /* Check for solvability. */
            if (d > (r0 + r1)) {
                /* no solution. circles do not intersect. */
                return false;
            }
            if (d < Math.abs(r0 - r1)) {
                /* no solution. one circle is contained in the other */
                return false; //return 'contained';
            }

            /* 'point 2' is the point where the line through the circle
             * intersection points crosses the line between the circle
             * centers.  
             */

            /* Determine the distance from point 0 to point 2. */
            a = ((r0 * r0) - (r1 * r1) + (d * d)) / (2.0 * d);

            /* Determine the coordinates of point 2. */
            x2 = x0 + (dx * a / d);
            y2 = y0 + (dy * a / d);

            /* Determine the distance from point 2 to either of the
             * intersection points.
             */
            h = Math.sqrt((r0 * r0) - (a * a));

            /* Now determine the offsets of the intersection points from
             * point 2.
             */
            rx = -dy * (h / d);
            ry = dx * (h / d);

            /* Determine the absolute intersection points. */
            var xi = x2 + rx;
            var xi_prime = x2 - rx;
            var yi = y2 + ry;
            var yi_prime = y2 - ry;

            return {
                cx0: xi,
                cy0: yi,
                cx1: xi_prime,
                cy1: yi_prime,
                circles: [
                    _1st,
                    _2nd
                ]
            }

        };

        // Get Intersection Dots
        let getIntersectionDots = (arr, _1stDot, _2ndDot) => {
            let intersect = intersection(_1stDot, _2ndDot);
            if (intersect) {
                let cross1 = {
                    x: intersect.cx0,
                    y: intersect.cy0,
                    r: 3
                };
                if (!_.isNaN(cross1.x) && !_.isNaN(cross1.y)) arr.push(cross1);
                let cross2 = {
                    x: intersect.cx1,
                    y: intersect.cy1,
                    r: 3
                };
                if (!_.isNaN(cross2.x) && !_.isNaN(cross2.y)) arr.push(cross2);
            }
        };

        // Get Intersection Dots with Circles
        let getIntersection = (arr, _1stDot, _2ndDot) => {
            let intersect = intersection(_1stDot, _2ndDot);
            if (intersect) {
                let _1stCross = {
                    x: intersect.cx0,
                    y: intersect.cy0,
                    r: 3
                };
                let _2ndCross = {
                    x: intersect.cx1,
                    y: intersect.cy1,
                    r: 3
                };
                if (!_.isNaN(_1stCross.x) && !_.isNaN(_1stCross.y) && !_.isNaN(_2ndCross.x) && !_.isNaN(_2ndCross.y)) {
                    arr.push({
                        "dots": [_1stCross, _2ndCross],
                        "circles": [intersect.circles[0], intersect.circles[1]]
                    });
                };

            }
        };

        let findAllIntersectionDots = (arr) => {
            // arr - dots
            // arr2 - intersections dots
            let arr2 = [];
            let arrFind1 = [],
                arrFind2 = [],
                i = 0;
            arr.forEach((item) => {
                if (i == 0) {
                    arrFind1.push(item);
                } else {
                    arrFind1.push(item);
                    arrFind2.push(item);
                }
                i = i + 1;
            });
            arrFind1.forEach((i1) => {
                arrFind2.forEach((i2) => {
                    getIntersectionDots(arr2, i1, i2);
                });
            });

            return arr2;
        };

        let findAllIntersections = (arr) => {
            // arr - dots
            // arr2 - intersections - complex data
            let arr2 = [];
            let arrFind1 = [],
                arrFind2 = [],
                i = 0;
            arr.forEach((item) => {
                //if (i == 0) {
                //    arrFind1.push(item);
                //} else {
                arrFind1.push(item);
                arrFind2.push(item);
                //}
                i = i + 1;
            });
            arrFind1.forEach((i1) => {
                arrFind2.forEach((i2) => {
                    getIntersection(arr2, i1, i2);
                });
            });

            return arr2;
        };


        let findAngleByTwoDots = (a, b) => {
            //an_rad = Math.atan2(b.y-a.y, b.x-a.x);
            return Math.atan2(b.y - a.y, b.x - a.x);
        };

        let findAngleByThreeDots = (a, b, c) => {
            // A first point
            // B center point
            // C second point
            var ab = Math.sqrt(Math.pow(b.x - a.x, 2) + Math.pow(b.y - a.y, 2));
            var bc = Math.sqrt(Math.pow(b.x - c.x, 2) + Math.pow(b.y - a.y, 2));
            var ac = Math.sqrt(Math.pow(c.x - a.x, 2) + Math.pow(c.y - a.y, 2));
            return Math.acos((bc * bc + ab * ab - ac * ac) / (2 * bc * ab));
        };

        let getAngleInDegrees = (an_rad) => {
            //deg_an = an_rad * 180 / Math.Pi
            return ((an_rad) * 180) / Math.PI;
        };

        function polarToCartesian(centerX, centerY, radius, angleInDegrees) {
            var angleInRadians = ((angleInDegrees) * Math.PI) / 180.0;

            return {
                x: centerX + (radius * Math.cos(angleInRadians)),
                y: centerY + (radius * Math.sin(angleInRadians))
            };
        }

        let pathPie = (x, y, startx, starty, radius1, radius2, longArcFlag, sweepArcFlag, endx, endy) => {
            return [
                "M", x, y,
                "L", startx, starty,
                "A", radius1, radius2, 0, longArcFlag, sweepArcFlag, endx, endy,
                "L", x, y
            ].join(" ");

        };

        function describeArc(x, y, radius, startAngle, endAngle) {
            var start = polarToCartesian(x, y, radius, endAngle);
            var end = polarToCartesian(x, y, radius, startAngle);

            var arcSweep = startAngle < endAngle ? "0" : "1";

            var arcLong = endAngle - startAngle <= 180 ? "0" : "1";

            return [
                "M", start.x, start.y,
                "A", radius, radius, 0, arcLong, arcSweep, end.x, end.y,
                "L", x, y,
                "L", start.x, start.y
            ].join(" ");
        }

        function describeArcIntersection(n) {
            var x = n.circles[0].x;
            var y = n.circles[0].y;
            var a = {
                x: x,
                y: y
            };
            var b = {
                x: n.dots[0].x,
                y: n.dots[0].y
            };
            var c = {
                x: n.dots[1].x,
                y: n.dots[1].y
            };
            var radius = n.circles[0].r;
            var startAngleRad = findAngleByTwoDots(a, b);
            var startAngle = getAngleInDegrees(startAngleRad);
            var endAngleRad = findAngleByTwoDots(a, c);
            var endAngle = getAngleInDegrees(endAngleRad);
            var start = polarToCartesian(x, y, radius, endAngle);
            var end = polarToCartesian(x, y, radius, startAngle);

            var arcSweep;
            arcSweep = startAngle < endAngle ? "0" : "1";
            var arcLong;
            arcLong = endAngle - startAngle <= 180 ? "0" : "1";

            if (startAngle < 0 && endAngle > 0) {
                console.log(0);
                if (arcLong == "0" && (startAngle * -1 + endAngle) < 180) {
                    arcLong = "0";
                    arcSweep = "0";
                } else {
                    arcLong = "0";
                    arcSweep = "1";
                }

            } else if (startAngle > 0 && endAngle < 0) {
                console.log(0);
                if (arcLong == "0" && (endAngle * -1 + startAngle) < 180) {
                    arcLong = "0";
                    arcSweep = "1";
                } else if (arcLong == "0" && (endAngle * -1 + startAngle) > 180) {
                    arcLong = "1";
                    arcSweep = "1";
                } else {
                    console.log(1);
                }
            } else {
                console.log(2);
            }

            return [
                "M", start.x, start.y,
                "A", radius, radius, 0, arcLong, arcSweep, end.x, end.y,
                "L", x, y,
                "L", start.x, start.y
            ].join(" ");
        }



        //
        //
        //
        let svg = d3.select("#tt").attr("width", window.innerWidth).attr("height", window.innerHeight);
        let d1Text = svg.append("text").attr("x", "0").attr("y", "10");
        let d2Text = svg.append("text").attr("x", "0").attr("y", "20");
        let g = svg.append('g')
            .attr('cursor', 'grab');
        let gdots = svg.append('g').attr("id", "dots");

        var c = {
            a: {
                id: 'a',
                x: 150,
                y: 150,
                r: 35
            },
            b: {
                id: 'b',
                x: 273,
                y: 84,
                r: 55
            },
            c: {
                id: 'c',
                x: 300,
                y: 100,
                r: 45
            },
            d: {
                id: 'd',
                x: 250,
                y: 50,
                r: 45
            },
            e: {
                id: 'e',
                x: 75,
                y: 80,
                r: 55
            },
            f: {
                id: 'f',
                x: 135,
                y: 115,
                r: 45
            },
            getArr: function() {
                return [this.a, this.b, this.c, this.d, this.e, this.f];
                //return [this.a, this.b, this.c];
            }
        };

        let arr = c.getArr();

        g.selectAll(".drag")
            .data(arr)
            .enter()
            .append("circle")
            .attr("class", "drag")
            .style("z-index", "100")
            .attr("id", d => d.id)
            .attr("r", d => d.r)
            .attr("cx", d => d.x)
            .attr("cy", d => d.y)
            .call(d3.drag()
                .on('start', dragstarted)
                .on('drag', dragged)
                .on('end', dragended));

        function dragstarted(id) {
            d3.select(this).raise();
            g.attr('cursor', 'grabbing');
        }

        function dragged(event, d) {
            let dd = [];

            d3.select(this)
                .attr('cx', d.x = event.x)
                .attr('cy', d.y = event.y);

            arr.forEach((i) => {
                if (i.id == d.id) {
                    i.x = d.x;
                    i.y = d.y;
                };

            });

            function returnd(n) {
                return describeArcIntersection(n);
            };

            dd = findAllIntersections(arr);
            let groups = gdots
                .selectAll(".group")
                .data(dd);

            groups.selectAll(".pie").remove();

            let groupsenter = groups.enter()
                .append("g")
                .attr("class", "group");

            let paths = groups.selectAll(".pie")
                .attr("d", returnd);

            groups.append("path")
                .attr("d", returnd)
                .attr("class", "pie")
                .style("stroke-width", "1px")
                .style("fill", "red")
                .style("fill-opacity", "0.1")
                .style("stroke", "red").style("z-index", "1");



            let dots = groups.selectAll(".dot").data(function(d) {
                    return d.dots;
                }).attr("cx", n => n.x)
                .attr("cy", n => n.y)
                .attr("r", n => n.r)
                .style("fill", "red");

            let dotsenter = dots.enter()
                .append("circle")
                .attr("class", "dot")
                .attr("r", n => n.r)
                .attr("cx", n => n.x)
                .attr("cy", n => n.y)
                .style("fill", "red");

            dots
                .exit()
                .remove();

            paths.exit().remove();

            groups
                .exit()
                .remove();


            /*
            //https://stackoverflow.com/questions/5736398/how-to-calculate-the-svg-path-for-an-arc-of-a-circle#18473154
//https://jsbin.com/quhujowota/1/edit?html,js,output



// 2



document.getElementById("theSvgArc").setAttribute("d", describeArc(150, 150, 100, 0, 190));
document.getElementById("theSvgArc2").setAttribute("d", describeArc(300, 150, 100, 90, 45));

// 1
function polarToCartesian(centerX, centerY, radius, angleInDegrees) {
  var angleInRadians = (angleInDegrees) * Math.PI / 180.0;

  return {
    x: centerX + (radius * Math.cos(angleInRadians)),
    y: centerY + (radius * Math.sin(angleInRadians))
  };
}

function describeArc(x, y, radius, startAngle, endAngle){

    var start = polarToCartesian(x, y, radius, endAngle);
    var end = polarToCartesian(x, y, radius, startAngle);

    var largeArcFlag = endAngle - startAngle <= 180 ? "0" : "1";

    var d = [
        "M", x, y,
        "L", start.x, start.y, 
        "A", radius, radius, 0, largeArcFlag, 0, end.x, end.y,
        "L", x, y
    ].join(" ");

    return d;       
}

window.onload = function() {
  document.getElementById("arc1").setAttribute("d", describeArc(150, 150, 100, 360-45,0));
};




                    svg.append("g")
                        .append("path")
                        .attr("d", function() {
                            return "M" + interPoints[0] + "," + interPoints[2] + "A" + r + "," + r +
                                " 0 0,1 " + interPoints[1] + "," + interPoints[3] + "A" + r + "," + r +
                                " 0 0,1 " + interPoints[0] + "," + interPoints[2];
                        })
                        .style('fill', 'red');
            */


        }

        function dragended() {
            g.attr('cursor', 'grab');
        }

        dd = findAllIntersections(arr);

        // 2
        let groups = gdots
            .selectAll(".group")
            .data(dd);

        let groupsenter = groups.enter()
            .append("g")
            .attr("class", "group");
        groupsenter.append("path")
            .attr("d", returnd)
            .attr("class", "pie")
            .style("stroke-width", "1px")
            .style("fill", "red")
            .style("fill-opacity", "0.1")
            .style("stroke", "red").style("z-index", "1");

        function returnd(n) {
            return describeArcIntersection(n);
        };

        let dots = groupsenter.selectAll(".dot")
            .data(function(d) {
                return d.dots;
            });

        let dotsenter = dots.enter()
            .append("circle")
            .attr("class", "dot")
            .attr("r", n => n.r)
            .attr("cx", n => n.x)
            .attr("cy", n => n.y)
            .style("fill", "red");

        dots
            .exit()
            .remove();

        groups
            .exit()
            .remove();
    </script>
</body>